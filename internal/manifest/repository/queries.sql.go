// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createLocalizations = `-- name: CreateLocalizations :exec
INSERT INTO manifest_localizations (manifest_id,
                                    locale,
                                    key,
                                    value)
SELECT $1,
       unnest($2::text[]),
       unnest($3::text[]),
       unnest($4::text[])
`

type CreateLocalizationsParams struct {
	ManifestID uuid.UUID
	Locales    []string
	Keys       []string
	Values     []string
}

func (q *Queries) CreateLocalizations(ctx context.Context, arg CreateLocalizationsParams) error {
	_, err := q.db.ExecContext(ctx, createLocalizations,
		arg.ManifestID,
		pq.Array(arg.Locales),
		pq.Array(arg.Keys),
		pq.Array(arg.Values),
	)
	return err
}

const createManifest = `-- name: CreateManifest :one
INSERT INTO manifest (id,
                      version,
                      icon,
                      category,
                      tags,
                      author_name,
                      author_email,
                      created_at,
                      meta_created_at,
                      signature)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        now(),
        now(),
        $8)
RETURNING id
`

type CreateManifestParams struct {
	ID          uuid.UUID
	Version     string
	Icon        string
	Category    string
	Tags        []string
	AuthorName  string
	AuthorEmail string
	Signature   string
}

func (q *Queries) CreateManifest(ctx context.Context, arg CreateManifestParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createManifest,
		arg.ID,
		arg.Version,
		arg.Icon,
		arg.Category,
		pq.Array(arg.Tags),
		arg.AuthorName,
		arg.AuthorEmail,
		arg.Signature,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createManifestContent = `-- name: CreateManifestContent :exec
INSERT INTO manifest_content (manifest_id,
                              ui,
                              script,
                              actions,
                              permissions)
VALUES ($1,
        $2,
        $3,
        $4,
        $5)
`

type CreateManifestContentParams struct {
	ManifestID  uuid.UUID
	Ui          json.RawMessage
	Script      string
	Actions     json.RawMessage
	Permissions []string
}

func (q *Queries) CreateManifestContent(ctx context.Context, arg CreateManifestContentParams) error {
	_, err := q.db.ExecContext(ctx, createManifestContent,
		arg.ManifestID,
		arg.Ui,
		arg.Script,
		arg.Actions,
		pq.Array(arg.Permissions),
	)
	return err
}

const getManifest = `-- name: GetManifest :one
WITH localization AS (SELECT ml.manifest_id,
                             json_object_agg(ml.key, ml.value) AS localization
                      FROM manifest_localizations ml
                      WHERE ml.locale = $2::text
                      GROUP BY ml.manifest_id)
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at,
       m.signature,
       mc.ui AS U_I,
       mc.script,
       mc.actions,
       mc.permissions,
       l.localization
FROM manifest m
         LEFT JOIN manifest_content mc ON mc.manifest_id = m.id
         LEFT JOIN localization l ON l.manifest_id = m.id
WHERE m.id = $1::uuid
`

type GetManifestParams struct {
	ManifestID uuid.UUID
	Locale     string
}

type GetManifestRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
	Signature     string
	UI            pqtype.NullRawMessage
	Script        sql.NullString
	Actions       pqtype.NullRawMessage
	Permissions   []string
	Localization  pqtype.NullRawMessage
}

func (q *Queries) GetManifest(ctx context.Context, arg GetManifestParams) (GetManifestRow, error) {
	row := q.db.QueryRowContext(ctx, getManifest, arg.ManifestID, arg.Locale)
	var i GetManifestRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Icon,
		&i.Category,
		pq.Array(&i.Tags),
		&i.AuthorName,
		&i.AuthorEmail,
		&i.CreatedAt,
		&i.MetaCreatedAt,
		&i.Signature,
		&i.UI,
		&i.Script,
		&i.Actions,
		pq.Array(&i.Permissions),
		&i.Localization,
	)
	return i, err
}

const listManifests = `-- name: ListManifests :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at,
       -- 🔽 отдаём **всю** локализацию для запрошенной локали
       (SELECT jsonb_object_agg(l.key, l.value)
        FROM manifest_localizations AS l
        WHERE l.manifest_id = m.id
          AND l.locale = $3::text) AS localization
FROM manifest AS m
ORDER BY m.created_at DESC
LIMIT $1 OFFSET $2
`

type ListManifestsParams struct {
	Limit   int64
	Offset  int64
	Column3 string
}

type ListManifestsRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
	Localization  json.RawMessage
}

func (q *Queries) ListManifests(ctx context.Context, arg ListManifestsParams) ([]ListManifestsRow, error) {
	rows, err := q.db.QueryContext(ctx, listManifests, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListManifestsRow
	for rows.Next() {
		var i ListManifestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
			&i.Localization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchManifests = `-- name: SearchManifests :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at
FROM manifest m
         LEFT JOIN manifest_localizations t
                   ON t.manifest_id = m.id
                       AND t.locale = $1
                       AND t.key = 'title'
         LEFT JOIN manifest_localizations d
                   ON d.manifest_id = m.id
                       AND d.locale = $1
                       AND d.key = 'description'
WHERE (
          -- empty search string => return everything
          ($2::text = '')
              -- full-text on title+description
              OR to_tsvector('english',
                             coalesce(t.value, '') || ' ' || coalesce(d.value, '')
                 ) @@ plainto_tsquery('english', $2::text)
              -- category ilike
              OR m.category ILIKE '%' || $2::text || '%'
              -- any tag matches
              OR EXISTS (SELECT 1
                         FROM unnest(m.tags) AS tag
                         WHERE tag ILIKE '%' || $2::text || '%')
          )
ORDER BY m.created_at DESC
`

type SearchManifestsParams struct {
	Locale string
	Search string
}

type SearchManifestsRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
}

func (q *Queries) SearchManifests(ctx context.Context, arg SearchManifestsParams) ([]SearchManifestsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchManifests, arg.Locale, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchManifestsRow
	for rows.Next() {
		var i SearchManifestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchManifestsFTS = `-- name: SearchManifestsFTS :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at,
       (SELECT jsonb_object_agg(l.key, l.value)
        FROM manifest_localizations AS l
        WHERE l.manifest_id = m.id
          AND l.locale = $1::text) AS localization
FROM manifest AS m
WHERE to_tsvector($2::regconfig,
                  (SELECT string_agg(l.value, ' ')
                   FROM manifest_localizations AS l
                   WHERE l.manifest_id = m.id
                     AND l.locale = $1::text
                     AND l.key IN ('title', 'description')) || ' ' ||
                  m.category || ' ' ||
                  array_to_string(m.tags, ' ')
      )
          @@ plainto_tsquery($2::regconfig, $3::text)
ORDER BY m.created_at DESC
`

type SearchManifestsFTSParams struct {
	Locale string
	Config interface{}
	Query  string
}

type SearchManifestsFTSRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
	Localization  json.RawMessage
}

func (q *Queries) SearchManifestsFTS(ctx context.Context, arg SearchManifestsFTSParams) ([]SearchManifestsFTSRow, error) {
	rows, err := q.db.QueryContext(ctx, searchManifestsFTS, arg.Locale, arg.Config, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchManifestsFTSRow
	for rows.Next() {
		var i SearchManifestsFTSRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
			&i.Localization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

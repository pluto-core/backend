// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const getManifest = `-- name: GetManifest :one
WITH localization AS (
    SELECT
        ml.manifest_id,
        json_object_agg(ml.key, ml.value) AS localization
    FROM manifest_localizations ml
    WHERE ml.locale = $2::text
    GROUP BY ml.manifest_id
)
SELECT
    m.id,
    m.version,
    m.icon,
    m.category,
    m.tags,
    m.author_name,
    m.author_email,
    m.created_at,
    m.meta_created_at,
    m.signature,
    mc.ui AS U_I,
    mc.script,
    mc.actions,
    mc.permissions,
    l.localization,
    l.localization ->> 'title'       AS title,
    l.localization ->> 'description' AS description
FROM manifest m
         LEFT JOIN manifest_content mc ON mc.manifest_id = m.id
         LEFT JOIN localization l ON l.manifest_id = m.id
WHERE m.id = $1::uuid
`

type GetManifestParams struct {
	ManifestID uuid.UUID
	Locale     string
}

type GetManifestRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
	Signature     string
	UI            pqtype.NullRawMessage
	Script        sql.NullString
	Actions       pqtype.NullRawMessage
	Permissions   []string
	Localization  pqtype.NullRawMessage
	Title         sql.NullString
	Description   sql.NullString
}

func (q *Queries) GetManifest(ctx context.Context, arg GetManifestParams) (GetManifestRow, error) {
	row := q.db.QueryRowContext(ctx, getManifest, arg.ManifestID, arg.Locale)
	var i GetManifestRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Icon,
		&i.Category,
		pq.Array(&i.Tags),
		&i.AuthorName,
		&i.AuthorEmail,
		&i.CreatedAt,
		&i.MetaCreatedAt,
		&i.Signature,
		&i.UI,
		&i.Script,
		&i.Actions,
		pq.Array(&i.Permissions),
		&i.Localization,
		&i.Title,
		&i.Description,
	)
	return i, err
}

const listManifests = `-- name: ListManifests :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at,
       t.value AS title,
       d.value AS description
FROM manifest m
         LEFT JOIN manifest_localizations t
                   ON t.manifest_id = m.id
                       AND t.locale = $3::text
                       AND t.key = 'title'
         LEFT JOIN manifest_localizations d
                   ON d.manifest_id = m.id
                       AND d.locale = $3::text
                       AND d.key = 'description'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListManifestsParams struct {
	Limit   int64
	Offset  int64
	Column3 string
}

type ListManifestsRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
	Title         sql.NullString
	Description   sql.NullString
}

func (q *Queries) ListManifests(ctx context.Context, arg ListManifestsParams) ([]ListManifestsRow, error) {
	rows, err := q.db.QueryContext(ctx, listManifests, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListManifestsRow
	for rows.Next() {
		var i ListManifestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchManifests = `-- name: SearchManifests :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at
FROM manifest m
         LEFT JOIN manifest_localizations t
                   ON t.manifest_id = m.id
                       AND t.locale = $1
                       AND t.key = 'title'
         LEFT JOIN manifest_localizations d
                   ON d.manifest_id = m.id
                       AND d.locale = $1
                       AND d.key = 'description'
WHERE (
          -- empty search string => return everything
          ($2::text = '')
              -- full-text on title+description
              OR to_tsvector('english',
                             coalesce(t.value, '') || ' ' || coalesce(d.value, '')
                 ) @@ plainto_tsquery('english', $2::text)
              -- category ilike
              OR m.category ILIKE '%' || $2::text || '%'
              -- any tag matches
              OR EXISTS (SELECT 1
                         FROM unnest(m.tags) AS tag
                         WHERE tag ILIKE '%' || $2::text || '%')
          )
ORDER BY m.created_at DESC
`

type SearchManifestsParams struct {
	Locale string
	Search string
}

type SearchManifestsRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
}

func (q *Queries) SearchManifests(ctx context.Context, arg SearchManifestsParams) ([]SearchManifestsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchManifests, arg.Locale, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchManifestsRow
	for rows.Next() {
		var i SearchManifestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchManifestsFTS = `-- name: SearchManifestsFTS :many
SELECT m.id,
       t.value AS title,
       d.value AS description,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at
FROM manifest AS m
         LEFT JOIN manifest_localizations AS t
                   ON t.manifest_id = m.id AND t.locale = $1::text AND t.key = 'title'
         LEFT JOIN manifest_localizations AS d
                   ON d.manifest_id = m.id AND d.locale = $1::text AND d.key = 'description'
WHERE to_tsvector($2::regconfig,
                  coalesce(t.value, '') || ' ' ||
                  coalesce(d.value, '') || ' ' ||
                  m.category || ' ' ||
                  array_to_string(m.tags, ' ')
      )
          @@ plainto_tsquery($2::regconfig, $3::text)
ORDER BY m.created_at DESC
`

type SearchManifestsFTSParams struct {
	Locale string
	Config interface{}
	Query  string
}

type SearchManifestsFTSRow struct {
	ID            uuid.UUID
	Title         sql.NullString
	Description   sql.NullString
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
}

func (q *Queries) SearchManifestsFTS(ctx context.Context, arg SearchManifestsFTSParams) ([]SearchManifestsFTSRow, error) {
	rows, err := q.db.QueryContext(ctx, searchManifestsFTS, arg.Locale, arg.Config, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchManifestsFTSRow
	for rows.Next() {
		var i SearchManifestsFTSRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const listManifests = `-- name: ListManifests :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at,
       t.value AS title,
       d.value AS description
FROM manifest m
         LEFT JOIN manifest_localizations t
                   ON t.manifest_id = m.id
                       AND t.locale = $3::text
                       AND t.key = 'title'
         LEFT JOIN manifest_localizations d
                   ON d.manifest_id = m.id
                       AND d.locale = $3::text
                       AND d.key = 'description'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListManifestsParams struct {
	Limit   int64
	Offset  int64
	Column3 string
}

type ListManifestsRow struct {
	ID            uuid.UUID
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
	Title         sql.NullString
	Description   sql.NullString
}

func (q *Queries) ListManifests(ctx context.Context, arg ListManifestsParams) ([]ListManifestsRow, error) {
	rows, err := q.db.QueryContext(ctx, listManifests, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListManifestsRow
	for rows.Next() {
		var i ListManifestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchManifests = `-- name: SearchManifests :many
SELECT m.id,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at
FROM manifest m
         LEFT JOIN manifest_localizations t
                   ON t.manifest_id = m.id
                       AND t.locale = $1
                       AND t.key = 'title'
         LEFT JOIN manifest_localizations d
                   ON d.manifest_id = m.id
                       AND d.locale = $1
                       AND d.key = 'description'
WHERE (
          -- empty search string => return everything
          ($2::text = '')
              -- full-text on title+description
              OR to_tsvector('english',
                             coalesce(t.value, '') || ' ' || coalesce(d.value, '')
                 ) @@ plainto_tsquery('english', $2::text)
              -- category ilike
              OR m.category ILIKE '%' || $2::text || '%'
              -- any tag matches
              OR EXISTS (SELECT 1
                         FROM unnest(m.tags) AS tag
                         WHERE tag ILIKE '%' || $2::text || '%')
          )
ORDER BY m.created_at DESC
`

type SearchManifestsParams struct {
	Locale string
	Search string
}

func (q *Queries) SearchManifests(ctx context.Context, arg SearchManifestsParams) ([]Manifest, error) {
	rows, err := q.db.QueryContext(ctx, searchManifests, arg.Locale, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Manifest
	for rows.Next() {
		var i Manifest
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchManifestsFTS = `-- name: SearchManifestsFTS :many
SELECT m.id,
       t.value AS title,
       d.value AS description,
       m.version,
       m.icon,
       m.category,
       m.tags,
       m.author_name,
       m.author_email,
       m.created_at,
       m.meta_created_at
FROM manifest AS m
         LEFT JOIN manifest_localizations AS t
                   ON t.manifest_id = m.id AND t.locale = $1::text AND t.key = 'title'
         LEFT JOIN manifest_localizations AS d
                   ON d.manifest_id = m.id AND d.locale = $1::text AND d.key = 'description'
WHERE to_tsvector($2::regconfig,
                  coalesce(t.value, '') || ' ' ||
                  coalesce(d.value, '') || ' ' ||
                  m.category || ' ' ||
                  array_to_string(m.tags, ' ')
      )
          @@ plainto_tsquery($2::regconfig, $3::text)
ORDER BY m.created_at DESC
`

type SearchManifestsFTSParams struct {
	Locale string
	Config interface{}
	Query  string
}

type SearchManifestsFTSRow struct {
	ID            uuid.UUID
	Title         sql.NullString
	Description   sql.NullString
	Version       string
	Icon          string
	Category      string
	Tags          []string
	AuthorName    string
	AuthorEmail   string
	CreatedAt     time.Time
	MetaCreatedAt time.Time
}

func (q *Queries) SearchManifestsFTS(ctx context.Context, arg SearchManifestsFTSParams) ([]SearchManifestsFTSRow, error) {
	rows, err := q.db.QueryContext(ctx, searchManifestsFTS, arg.Locale, arg.Config, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchManifestsFTSRow
	for rows.Next() {
		var i SearchManifestsFTSRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Version,
			&i.Icon,
			&i.Category,
			pq.Array(&i.Tags),
			&i.AuthorName,
			&i.AuthorEmail,
			&i.CreatedAt,
			&i.MetaCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
